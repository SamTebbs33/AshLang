#include <parser/tokens.h>
#include <loader/context.h>
#include <loader/member.h>
#include <error/errors.h>

void TokenFile::preParse(){
	Context::push(FileContext("", Members::toQualifiedName(&namespc.name, "")));
	namespc.preParse();
	foreach(it, imports.imports) (*it).preParse();
	foreach(it, typeDecs) if(*it) (*it)->preParse();
}

void TokenNamespace::preParse(){}

void TokenImport::preParse(){
	ClassLoader::importClass(name.paths);
}

void TokenBlock::preParse(){}

void TokenDeclaration::preParse(){}

void TokenTypeDec::preParse(){
	if(!Members::typeExists(*id.str)){
		// Create the qualified name of this type
		QualifiedName name = Context::getNamespace();
		name.add(*id.str);
		Members::addAndEnterType(new Type(mods, name));
		block.preParse();
	}else{
		Error::semanticError("Type already exists (" + *id.str + ")");
	}
}

void TokenClassDec::preParse(){
	TokenTypeDec::preParse();
	//TODO: Add supers to Type generated by TokenTypeDec::preParse()
}

void TokenProtocolDec::preParse(){
	TokenTypeDec::preParse();
	//TODO: Add supers to Type generated by TokenTypeDec::preParse()
}

void TokenEnumDec::preParse(){
	TokenTypeDec::preParse();
}

void TokenFuncDec::preParse(){
	QualifiedName name = Members::getCurrentTypeQualifiedName();
	// Form a qualified name to this function
	name.add(*id.str);
	Members::addFunction(new FuncSignature(name, &args, mods));
}

void TokenVarDec::preParse(){}
